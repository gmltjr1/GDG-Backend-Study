## 객체 지향이란
* 객체 지향 프로그래밍
  * 컴퓨터 프로그램을 객체들의 상호작요으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임
  * 유연하고 변경에 유리
* 객체지향의 네 가지 특징
  * 추상화 : 객체의 공통적인 속성과 기능을 추출하여 정의하는것
  * 캡슐화 : 서로 연관되어 있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것
  * 상속 : 기존 클래스의 속성과 기능을 새로운 클래스가 물려받아 재사용 하는 것
  * 다형성 : 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
    * 어떤 역할에 대해 여러 가지 구현방식으로 존재할 수 있는 것
    * 예시1) 역할(자동차) -> 구현 방식(bmw, 포르쉐 등)
    * 예시2) 역할(정렬) -> 구현 방식(버블, 삽입, 병합 정렬 등)
    * 클라이언트는 대상의 역할만 알면 된다.
* 다형성의 적용
  * 역할을 만들어 놓고 그 역할을 수행하는 구현체를 바꿔끼기
  * 역할 -> 인터페이스(클래스가 수현해야 하는 메소드의 집합. 클래스의 설계도, 틀)
  * 구현 -> 인터페이스를 구현한 클래스
## SOLID 원칙
  * 좋은 객체지향 설계를 위한 5원칙
  * SRP 단일 책임 원칙
    * 하나의 클래스는 단 한개의 책임을 가져야함
    * 클래스를 변경하는 이유는 단 하나여야 함
    * 프로그램의 유지보수성 높임
  * OCP 개방 - 폐쇠 원칙
    * 클래스는 확장에 열려있어야 하면, 수정에는 닫혀 있어야 함
    * 기존 코드를 변경하지 않고 기능을 확장할 수 있도록 설계
  * LSP 리스코프 치환 원칙
    * 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 함
    * 자식 클래스가 부모 클래스의 기능을 변경하면 안 됨
    * 행동의 호환성(기능의 일치)
  * ISP 인터페이스 분리 원칙
    * 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야함
  * DIP 의존관계 역전 원칙
    * 구현 클래스에 의존하지 말고, 인터페이스에 의존해야한다
    * 변화하기 쉬운 것 보단 변화하기 어려운 것에 의존
    * +)의존 : 한 객체가 다른 객체의 기능을 필요로 해서 사용하는 관계
* 다형성 만으로 solid 원칙을 지킬 수 없음.
* 스프링이 solid 원칙을 지키기 위해 __의존성 주입__ 을 지원한다

## Spring Bean, DI, IoC
* IoC(inversion of control)
  * 객체 생성 및 관리에 대한 제어권을 개발자가 아닌 프레임 원크가 대신 가져가는 것
  * 스프링에서는 객체 생성 및 관리를 스프링 컨테이너가 함
  * 스프링 컨테이너 = IoC 컨테이너
* Spring Container
  * 스프링 빈 저장소
  * 애플리케이셔 컨텍스트
* Spring Bean
  * 어플리케이션 전역에서 사용할 공용 객체
  * 스프링 컨테이너가 관리하는 객체(스프링 컨테이너에 저장, 필요한 빈을 컨테이너에서 받음)
* 싱글톤 컨테이너
  * 객체를 딱 1개만 생성해서 필요할때마다 재사용할 수 있게 한다.
  * 매번 생성x, 생성해둔 객체를 사용하므로 메모리를 효율적 사용
* Spring Bean 등록 방법
  * 설정 파일 작성(수동)
    * @Configuration으로 설정 클래스를 생성
      * 등록하고자 하는 객체를 반환하는 메서드에 @Bean 붙이기
    * 스프링 컨테이너가 설정 클래스에서 @Bean이 붙은 메서드를 통해 bean 등록
  * 컴포넌트 스캔(자동) - 빈에 @Component 붙이기
    1. @ComponentScan 컴포넌트 스캔
       * 어떤 클래스들이 Spring Bean인지 찾아서 등록
       * @SpringBootApplication에 포함
    2. @Component 컴포넌트
       * Spring Bean인 클래스 표시
       * @Controller, @Service, @Repository 등에 포함
* DI(Dependency Injection)
  * IoC를 구현하는 방법(의존하는 객체를 밖에서 주입)
  * 스프링 컨테이너에 필요한 객체(Bean)를 미리 생성해두고, 다른 객체에서 이 객체가 필요할 떄 주입하는 것
  * 클라이언트 관점
    * 인터페이스에만 의존, 구현 객체는 외부에서 주입
    * 애플리케이션 실행 시점에 객체 간의 관계를 결정
  * 유연성, 유지보수성 높임
* 수동 DI구현 방식
  * 설정 클래스 파일에서 클라이언트 객체 생성자의 인자로 전달
  * 설정 클래스를 통해 어떤 구현체를 사용할지 결정
* 자동 DI구현 방식
  * application 파일에 @SpringBootApplication 컴포넌트 존재(실행 시점에 자동 스캔 및 스프링 빈 생성)
  * @Autowired 스프링 컨테이너에 등록된 빈 중에서 필요한 타입의 객체를 자동으로 주입
      1. 생성자 주입(권장)
          * 클라이언트 객체의 생성자 위에 표시 -> 생성 시점에 연결
          * 의존성 주입 강제
          * 불변성(final 선언 가능)
          * 필드가 하나라면 @Autowired 생략 가능.
            대신 클래스 위 @RequiredArgsConstructor로 final이 붙은 필드의 생성자 자동 생성
      2. 수정자 주입
          * set- 메소드 위에 붙임
          * 변경 가능성이 있는 의존 관계에 사용
          * 선택적인 의존성 주입(생성 시점에 필수x)
      3. 필드 주입(비권장)
          * 필드 위에 바로 붙임
          * 변경 가능성, 의존관계 파악 힘듦, 테스트 힘듦
  * 조회되는 빈이 2개 이상일 떄
    * @Qualifier
      * 빈에 추가 이름표를 붙여줌
      * 생성자에서 원하는 이름표 명시
    * @Primary
      * 빈 클래스 위에 붙이면 우선순위가 생김
  * 기능을 확장할 필요가 없다면
    * 우선 구체 클래스로 바로 구현하고 나중에 확장이 필요해졌을 떄 리팩터링을 통해 도입하는 것도 좋은 선택