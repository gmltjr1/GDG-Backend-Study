## Repository Layer
* 데이터베이스에 접근하여 CRUD 작업을 수행
  * Create : 생성
  * Read : 조회
  * Update : 수정
  * Delete : 삭제

## ORM과 JPA
* 데이터베이스에 접근하려면
  * 애플리케이션 서버는 SQL을 연결된 커넥션을 통해 DB에 전달
  * DB는 전달된 SQL을 수행하고 결과를 응답, 애플리케이션 서버는 결과 활용
  * JDBC
    * Java에서 Database에 접근하기 위한 표준화된 API
* SQL을 직접 다루는 방식의 비효율성 -> ORM의 필요성
  * 패러다임 불일치(객체 - 데이터베이스), 반복적인 SQL코드 작성 등
* __ORM__ (Object-Relational Mapping)
  * 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것
    Object <-> ORM <-> Database
  * 반복적인 CRUD SQL 자동으로 처리
* __JPA__ (Java Persistence API)
  * 자바 진영의 ORM 기술 표준
  * 자바에서 객체를 데이터베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API
  * 대표적인 JPA 구현체는 Hibernate
### JPA 동작 방식
* Entity Manager : 엔티티 객체를 데이터베이스와 연결해주는 창구 역할
  * JPA의 기능 대부분 제공
  * 엔티티 매니저를 사용해서 SQL을 직접 작성하지 않고도 엔티티를 데이터베이스에 CRUD 가능
  * 엔티티를 영속성 컨텍스트에 저장
* 엔티티 : 데이터베이스에 저장할 객체, 테이블과 1:1 매핑되는 객체
* 영속성 컨텍스트 : JPA에서 엔티티를 관리하기 위해서 만들어져있는 가상 공간
  * 엔티티 매니저를 통해 영속성 컨텍스트에 접근
  * 특징 : 1차캐시, 동일성 보장, 트랜잭션 지원하는 쓰기 지연, 변경 감지
* 트랜잭션 : 데이터베이스에서 수행되는 작업의 단위
  * 여러개의 데이터베이스 연산을 하나의 논리적인 작업 단위로 묶어서 실행
    * 모든 연산이 성공적 -> 트랜잭션을 커밋하여 데이터베이스에 반영
    * 하나라도 실패 -> 롤백하여 이전상태로 되돌림
  * 더이상 쪼갤 수 없는 원자성을 가짐
* 엔티티 생명 주기
  * 비영속 : 영속성 컨텍스트와 관련x
  * 영속 : 영속성 컨텍스트에 저장 
  * 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
  * 삭제 : 영속성 컨텍스트에 엔티티가 삭제될거라고 기록한 상태
* 예시(트랜잭션을 지원하는 쓰기 지연 -> 최적화)
  * 엔티티 등록 : (em.persist(member1))
    * 멤버엔티티1은 비영속상태에서 영속상태(영속성 컨텍스트에 저장)로 변함
    * 등록을 위한 SQL문 보관
  * 엔티티 등록 : em.persist(member2
    * 멤버엔티티1과 함께 영속성 컨텍스트에 저장
  * 트랜잭션 커밋(INSERT커밋) : em.flush()
    * 데이터베이스에 동기화(멤버엔티티1, 멤버엔티티2)
    * 쿼리를 모아뒀다가 한 번에 실행
* 예시(1차캐시, 동일성 보장)
  * 엔티티 조회 : em.find(member1)
    1. 영속성 컨텍스트 확인
    2. DB 조회, SELECT 쿼리
    3. 1차캐시에 저장 (멤버엔티티1)
    4. 반환(멤버엔티티1)
  * 한 번 더 조회(같은 트랜잭션) : em.find(member1)
    1. 영속성 컨텍스트 확인(__1차 캐시__에 존재)
    2. 반환 (아까 확인한 멤버 엔티티1와 __동일성 보장__)
* 예시(변경 감지 : 변경 사항을 자동으로 감지하고 커밋 시점에 DB에 반영. 영속상태에만 적용)
  * 엔티티 수정 : em.find(member1)
    1. 멤버 엔티티1 영속성 컨텍스트에 저장
    2. 멤버의 이름, 주소 수정
  * 트랜잭션 커밋(자동) : em.flush()
    1. 엔티티의 최초 상태와 현재 상태를 비교
    2. 변경을 감지하고 UPDATE쿼리 생성해 전달
* 예시
  1. 엔티티 조회 : em.find(member1)
    * 멤버엔티티1 영속상태
  2. 엔티티 삭제 : em.remove(member1)
    * 멤버엔티티1 삭제대상으로 표시
    * 영속성 컨텍스트에서 관리x
  3. 트랜잭션 커밋 : em.flush()
    * DELETE SQL을 저장해 뒀다가 실행
* JPQL
  * 리스트를 받는 것 처럼 복잡한 조회일 겨우 사용
  * SQL과 비슷하지만, 테이블이 아니라 엔티티 객체를 기준으로 쿼리 작성